#!/bin/bash

# Use k3d to create a k3s cluster that's usable for Ambassador, AES, and
# Telepresence development

set -o errexit
set -o pipefail
set -o nounset

k3d get-kubeconfig >& /dev/null || k3d c --enable-registry -x=--no-deploy=traefik --wait 90 1>&2
k3d start
reg=registry.local:5000
telver=$(telepresence --version)
# Check for prerequisites
docker ps > /dev/null
k3d -h > /dev/null
kubectl -h > /dev/null

# Show messages to the user on stderr. We use stdout to emit environment
# variables to be eval'ed.
show() { echo "$@" 1>&2; }

# Use k3d to start k3s in a Docker container.
show "--> Starting k3s"

fi

if telepresence --version > /dev/null; then
    # Telepresence's `make check` insists on building and pushing images every
    # time (with a build-specific tag), so it's helpful to set
    # TELEPRESENCE_REGISTRY to the local registry to make that fast. However,
    # that also causes normal usage of Telepresence to try to pull from the
    # local registry (with a normal version tag, like :0.104). So this script
    # pushes the normal Telepresence images to the local registry for
    # convenience. You can drop this section if you don't hack on Telepresence.
    # That said, only the first run is slow.
    show "--> Copying Telepresence images from (implicit) docker.io to ${reg}"

    telver=$(telepresence --version)
    if ! docker pull -q "${reg}/telepresence-local:${telver}" >& /dev/null; then
        for suffix in k8s k8s-priv local; do  # skip ocp because we probably won't use it on k3s
            docker pull -q "datawire/telepresence-${suffix}:${telver}" > /dev/null
            docker tag "datawire/telepresence-${suffix}:${telver}" "${reg}/telepresence-${suffix}:${telver}" > /dev/null
            docker push "${reg}/telepresence-${suffix}:${telver}" > /dev/null
        done
    fi
fi

# The kubeconfig generated by k3d works fine as-is from the host, but we need to
# use a kubeconfig file from within Docker containers (e.g., the Ambassador
# builder container). So this script generates a container-friendly version by
# replacing the "localhost" address in the original configuration file with the
# Docker network address for the k3s container. That address is reachable from
# within other containers in the same Docker network (achieved by setting
# DOCKER_NETWORK below). And it's reachable from the host on Linux, but not on
# MacOS.
#
# For local use (from the host), we use the original kubeconfig, which works on
# MacOS and Linux. For container use (via the DEV_KUBECONFIG variable), we use
# the container-friendly version.
show "--> Getting kubeconfig and mangling for use from within other containers"

KUBECONFIG=~/.kube/k3s.yaml
NEW_IP=$(docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' k3d-k3s-default-server)
sed -e "s/127.0.0.1/$NEW_IP/g" -e "s/localhost/$NEW_IP/g" < "$(k3d get-kubeconfig)" > "$KUBECONFIG"
export KUBECONFIG

# Create a deployment and service in the new cluster to verify that it is
# working and to have a target for curl commands. I'd create a Mapping too, but
# a fresh cluster has no Mapping CRD!
show "--> Setting up hello service/deployment"

if ! kubectl get svc,deploy hello >& /dev/null; then
    kubectl create deploy hello --image=ark3/hello-world >& /dev/null
    kubectl expose deploy hello --port 80 --target-port 8000 >& /dev/null
fi

cat <<EOF
export DOCKER_REGISTRY=$reg DEV_REGISTRY=$reg TELEPRESENCE_REGISTRY=$reg VERSION_SUFFIX= KUBECONFIG=$KUBECONFIG DEV_KUBECONFIG=$KUBECONFIG DOCKER_NETWORK=k3d-k3s-default
# eval \$(k3s)
EOF
show "--> Done"
